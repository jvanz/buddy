package common

import (
	"bufio"
	"errors"
	"log"
	"os"
	"strings"
)

// isHeaderLine checks if the given line is the first line of a header from a
// file generated by supportutil. For that, it checks if line starts with "#==["
// Returns true if the given line is the first line of a header
func isHeaderLine(line string) bool {
	return strings.HasPrefix(strings.TrimSpace(line), `#==[`)
}

// isCommandHeader checks if the given line is a header of a command. It does
// not check if the line is or not a header. It just checks if the line contains
// the string "[ Command ]".
// Returns true if the given line is the first line of a header showing a command
// output. Otherwise, returns false
func isCommandHeader(line string) bool {
	return strings.Contains(line, "[ Command ]")
}

// getFileSections send the sections found in the given filepath and publishes
// the section data into the sectionChan channel. It close the channel in the
// end
func getFileSections(filepath string, sectionChan chan string) {
	file, err := os.Open(filepath)
	defer close(sectionChan)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	section := ""
	for scanner.Scan() {
		line := scanner.Text()
		if isHeaderLine(line) {
			if len(section) > 0 {
				sectionChan <- strings.TrimSpace(section)
			}
			section = line + "\n"
		} else {
			section = section + line + "\n"
		}
	}
	if len(section) > 0 {
		sectionChan <- section
	}
	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}
}

// GetCommand read the filepath looking for "Command" sections and pusblies them
// into the commandChan channel. It closes the channel in the end.
func GetCommand(filepath string, commandChan chan string) {
	resultChan := make(chan string)
	defer close(commandChan)
	go getFileSections(filepath, resultChan)

	for section := range resultChan {
		scanner := bufio.NewScanner(strings.NewReader(section))
		scanner.Scan()
		line := scanner.Text()
		if err := scanner.Err(); err != nil {
			log.Fatal(err)
		}
		if isCommandHeader(line) {
			commandChan <- section
		}
	}
}

// matchCommand checks if the given section is generated by the given command.
func matchCommand(section string, cmd string) bool {
	scanner := bufio.NewScanner(strings.NewReader(section))
	scanner.Scan() // ignore the first line, the header
	scanner.Scan()
	cmdline := scanner.Text()
	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}
	return strings.Contains(cmdline, cmd)
}

// FindCommand reads the filepath looking for the given command. If the command
// is found, the section data is returned. Otherwise, it returns an error
func FindCommand(filepath string, command string) (string, error) {
	cmdChan := make(chan string)
	go GetCommand(filepath, cmdChan)

	for cmd := range cmdChan {
		if matchCommand(cmd, command) {
			return strings.TrimSpace(cmd), nil
		}
	}
	return "", errors.New("Command not found")
}
